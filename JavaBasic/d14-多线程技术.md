# 第一章：相关概念
## 1.1 并发和并行
- 并行（ parallel ）：指两个或多个事件在 同一时刻 发生（同时发生）。指在同一时刻，有多条指令在多个处理器上同时执行。
- 并发（ concurrency ）：指两个或多个事件在 同一个时间段内 发生。指在同一个时刻只能有一条指令执行，但多个进程的指令被快速轮换执行，使得在宏观上具有多个进程同时执行的效果。
>在操作系统中，安装了多个程序，并发指的是在一段时间内宏观上有多个程序同时运行，这在单 CPU 系统中，每一时刻只能有一个程序执行，即微观上这些程序是分时的交替运行，只不过是给人的感觉是同时运行，那是因为分时交替运行的时间是非常短的。
>而在多个 CPU 系统中，则这些可以并发执行的程序便可以分配到多个处理器上（ CPU ），实现多任务并行执行，即利用每个处理器来处理一个可以并发执行的程序，这样多个程序便可以同时执行。目前电脑市场上说的多核 CPU ，便是多核处理器，核越多， 并行 处理的程序越多，能大大的提高电脑运行的效率。
* 注意：单核 处理器的计算机肯定是 不能并行 的处理多个任务的，只能是多个任务在单个 CPU 上并发运行。同理，线程也是一样的，从宏观角度上理解线程是并行运行的，但是从微观角度上分析却是串行运行的，即一个线程一个线程的去运行，当系统只有一个 CPU 时，线程会以某种顺序执行多个线程，我们把这种情况称之为线程调度。
- 单核 CPU ：只能并发。
- 多核 CPU ：并发+并行。
- 例子：
>并行：多项工作一起执行，之后再汇总，例如：泡方便面，电水壶烧水，一边撕调料倒入桶中
>并发：同一时刻多个线程在访问同一个资源，多个线程对一个点，例如：春运抢票、电商秒杀...
## 1.2 进程和线程
- 程序 ：为了完成某个任务和功能，选择一种编程语言编写的一组指令的集合。
- 软件 ：1个或多个应用程序+相关的素材和资源文件等构成一个软件系统。
- 进程 ：是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。
- 线程 ：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。
- 简而言之：一个软件中至少有一个应用程序，应用程序的一次运行就是一个进程，一个进程中至少有一个线程。
进程是操作系统调度和分配资源的最小单位，线程是 CPU 调度的最小单位。不同的进程之间是不共享内存的。进程之间的数据交换和通信的成本是很高。不同的线程是共享同一个进程的内存的。当然不同的线程也有自己独立的内存空间。对于方法区，堆中中的同一个对象的内存，线程之间是可以共享的，但是栈的局部变量永远是独立的。
## 1.3 线程调度
- 分时调度：所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。
- 抢占式调度：优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java 使用的为抢占式调度。
## 1.4 多线程的应用场景
程序需要同时执行两个或多个任务。
程序需要实现一些需要等待的任务时，如用户输入、文件读写 操作、网络操作、搜索等。
需要一些后台运行的程序时。
# 第二章：线程的创建和使用
## 2.1 概述
Java 语言的 JVM 允许程序运行多个线程，它通过 java.lang.Thread 类来体现。
- Thread 类的特性：
每个线程都是通过某个特定 Thread 对象的 run() 方法来完成操作的，经常 把 run() 方法的主体称为 线程体 。
通过该 Thread 对象的 start() 方法来启动这个线程，而非直接调用 run() 。
## 2.1 JDK 5之前创建线程的方式
### 2.1.1 概述
JDK 5 之前创建线程的两种方式：
- ① 继承Thread类。
- ② 实现Runnable接口。
### 2.1.2 继承 Thread 类
- 步骤：
   - ① 定义子类继承 Thread 类。
   - ② 子类中重写 Thread 类中的 run 方法。
   - ③ 创建 Thread 子类对象，即创建了线程对象。。
   - ④ 调用线程对象 start 方法：启动线程，调用 run 方法。
-注意事项：
   - ① 如果自己手动调用 run() 方法，那么就只是普通方法，没有启动多线程模式。
   - ② run() 方法由 JVM 调用，什么时候调用，执行的过程控制都有操作系统的 CPU 调度决定。
   - ③ 想要启动多线程，必须调用 start 方法。
   - ④ 一个线程对象只能调用一次 start() 方法启动，如果重复调用了，则将抛出以上的异常 IllegalThreadStateException 。

### 2.1.3 实现 Runnable 接口
- 步骤：
   - ① 定义子类，实现 Runnable 接口。
   - ② 子类中重写 Runnable 接口中的 run 方法。
   - ③ 通过 Thread 类含参构造器创建线程对象。
   - ④ 将 Runnable 接口的子类对象作为实际参数传递给 Thread 类的构造器中。
   - ⑤ 调用 Thread 类的 start 方法：开启线程，调用 Runnable 子类接口的 run 方法。

### 2.1.4 继承方式和实现方式的区别
- 区别：
   - ① 继承 Thread 类：线程代码存放在 Thread 子类的 run() 方法中。
   - ② 实现 Runnable 接口：线程代码存放在接口的子类的 run() 方法中。
- 实现方式的好处：
   - ① 避免了单继承的局限性。
   - ② 多个线程可以共享同一个接口实现类的对象，非常适合多个相同线 程来处理同一份资源。
### 2.2 设置线程名称和获取线程名称
- 设置线程名称：
```
public final synchronized void setName(String name)
public Thread(Runnable target, String name)
public Thread(String name)
```
- 获取当前线程：
```public static native Thread currentThread();```
- 获取线程的名称：
```public final String getName()```
## 2.3 线程的优先级
每个线程都有一定的优先级，优先级高的线程将获得较多的执行机会。
Thread 类提供了以下方法来设置和获取线程的优先级：
- 设置线程的优先级：
```setPriority(int newPriority)```
- 获取线程的优先级：
```getPriority()```
-其中 setPriority 方法需要一个整数，并且范围在 [1,10] 之间，通常推荐设置 Thread 类的三个优先级常量：
```java
public final static int MIN_PRIORITY = 1;
public final static int NORM_PRIORITY = 5;
public final static int MAX_PRIORITY = 10;
```
- 注意：
线程创建时继承的是父线程的优先级。
低优先级只是获得调度的概率低，并非一定是在高优先级线程之后才被调用。
- 
## 2.4 等待线程终止（了解）
等待该线程终止：
```void join()```
等待该线程终止的时间最长为 millis 毫秒。如果 millis 时间到，将不再等待：
```void join(long millis)```
等待该线程终止的时间最长为 millis 毫秒 + nanos 纳秒：
```void join(long millis, int nanos)```

# 第三章：线程安全
## 3.1 售票程序引出线程安全
## 3.2 线程安全的原因
多线程环境下操作同一个资源（成员变量）。
## 3.3 线程安全的解决方法
对多条操作共享数据的语句，只能让一个线程都执行完，在执行过程中，其他线程不可以参与执行。
## 3.4 JDK 5 之前解决线程安全
### 3.4.1 概述
Java 对于多线程的安全问题提供了专业的解决方式：同步机制 。

- 同步代码块：
```synchronized (对象){ 
    // 需要被同步的代码
}
```
- 同步方法：
```
权限修饰符 synchronized 返回值类型 方法名(形参列表){
    // 需要被同步的代码
}
```
### 3.4.2 同步机制中的锁
- 同步锁机制：在《Thinking in Java》中，是这么说的：对于并发工作，你需要某种方式来防止两个任务访问相同的资源（其实就是共享资源竞争）。 防止这种冲突的方法 就是当资源被一个任务使用时，在其上加锁。第一个访问某项资源的任务必须 锁定这项资源，使其他任务在其被解锁之前，就无法访问它了，而在其被解锁之时，另一个任务就可以锁定并使用它了。
> synchronized 的锁是什么？
> 任意对象都可以作为同步锁。所有对象都自动含有单一的锁（监视器）。
> 同步方法的锁：静态方法（ 类名.class ）、非静态方法（ this ）。
> 同步代码块：自己指定，很多时候也是指定为 this 或 类名.class 。
- 注意事项：
必须确保使用同一个资源的 多个线程共用一把锁 ，这个非常重要，否则就无法保证共享资源的安全。
一个线程类中的所有静态方法共用同一把锁（ 类名.class ），所有非静态方 法共用同一把锁（ this ），同步代码块（指定需谨慎）。

3.5 死锁
- 死锁：
> 不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁。
> 出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续。
- 解决方法：
> 专门的算法、原则。
> 尽量减少同步资源的定义。
> 尽量避免嵌套同步。

## 3.6 synchronized 与 Lock 的对比
- ① Lock 是显式锁（手动开启和关闭锁，别忘记关闭锁），synchronized 是隐式锁，出了作用域自动释放。
- ② Lock 只有代码块锁，synchronized 有代码块锁和方法锁。
- ③ 使用 Lock 锁，JVM 将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类）。
# 第四章：线程通信
## 4.1 为什么需要线程通信？
多个线程在处理同一个资源，但是处理的动作（线程的任务）却不相同。而多个线程并发执行时, 在默认情况下CPU是随机切换线程的，当我们需要多个线程来共同完成一件任务，并且我们希望他们有规律的执行, 那么多线程之间需要一些通信机制，可以协调它们的工作，以此来帮我们达到多线程共同操作一份数据。
比如：线程A用来生成包子的，线程B用来吃包子的，包子可以理解为同一资源，线程A与线程B处理的动作，一个是生产，一个是消费，此时B线程必须等到A线程完成后才能执行，那么线程A与线程B之间就需要线程通信，即—— 等待唤醒机制 。
## 4.2 等待唤醒机制
等待唤醒机制是多个线程的一种 协作 机制。谈到线程我们经常想到的是线程间的 竞争（race） ，比如去争夺锁，但是线程间也会有协作机制。
等待唤醒机制就是在一个线程满足某个条件时，就进入等待状态（ wait()/wait(time) ）， 等待其他线程执行完他们的指定代码过后再将其唤醒（ notify() ）或可以指定 wait 的时间，等时间到了自动唤醒；在有多个线程进行等待时，如果需要，可以使用 notifyAll() 来唤醒所有的等待线程。wait/notify 就是线程间的一种协作机制。
- wait() ：令当前线程挂起并放弃CPU、同步资源并等待，使别的线程可访问并修改共享资源，而当 前线程排队等候其他线程调用notify()或notifyAll() 方法唤醒，唤醒后等待重新获得对监视器的所有 权后才能继续执行。
- notify() ：唤醒正在排队等待同步资源的线程中优先级最高者结束等待。
- notifyAll () ：唤醒正在排队等待资源的所有线程结束等待。
- 注意：
被通知线程被唤醒后也不一定能立即恢复执行，因为它当初中断的地方是在同步块内，而此刻它已经不持有锁，所以她需要再次尝试去获取锁（很可能面临其它线程的竞争），成功后才能在当初调用 wait 方法之后的地方恢复执行。
如果能获取锁，线程就从 WAITING 状态变成 RUNNABLE（可运行） 状态；否则，线程就从 WAITING 状态又变成 BLOCKED（等待锁） 状态
调用 wait 和 notify 方法需要注意的细节：
   - ① wait 方法与 notify 方法必须要由同一个锁对象调用。因为：对应的锁对象可以通过 notify 唤醒使用同一个锁对象调用的 wait 方法后的线程。
   - ② wait 方法与 notify 方法是属于 Object 类的方法的。因为：锁对象可以是任意对象，而任意对象的所属类都是继承了Object 类的。
   - ③ wait 方法与 notify 方法必须要在同步代码块或者是同步函数中使用。因为：必须要通过锁对象调用这 2 个方法。
## 4.3 生产者和消费者问题
等待唤醒机制可以解决经典的 生产者与消费者 的问题。
生产者与消费者问题，也称有限缓冲问题，是一个多线程同步问题的经典案例。该问题描述了两个（多个）共享固定大小缓冲区的线程——即所谓的 生产者 和 消费者 ——在实际运行时会发生的问题。生产者的主要作用是生成一定量的数据放到缓冲区中，然后重复此过程。与此同时，消费者也在缓冲区消耗这些数据。该问题的关键就是要保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区中空时消耗数据。

- 生产者与消费者问题中其实隐含了两个问题：
   - ① 线程安全问题：因为生产者与消费者共享数据缓冲区，不过这个问题可以使用同步解决。
   - ② 线程的协调工作问题：
>要解决该问题，就必须让生产者线程在缓冲区满时等待( wait )，暂停进入阻塞状态，等到下次消费者消耗了缓冲区中的数据的时候，通知( notify )正在等待的线程恢复到就绪状态，重新开始往缓冲区添加数据。
>同样，也可以让消费者线程在缓冲区空时进入等待( wait )，暂停进入阻塞状态，等到生产者往缓冲区添加数据之后，再通知( notify )正在等待的线程恢复到就绪状态。
>通过这样的通信机制来解决此类问题。
  
## 4.4 sleep() 和 wait() 方法的区别
- sleep() 不释放锁，wait() 释放锁。
- sleep() 指定休眠的时间，wait() 可以指定时间也可以无限等待直到 notify 或 notifyAll 。
- sleep( )在 Thread 类中声明的静态方法，wait 方法在 Object 类中声明。
## 4.5 生产者和消费者性能问题（多生产者和多消费者案例）
wait() 方法和 notify() 方法都是本地方法，会调用 OS 的功能，和操作系统交互，JVM 找 OS ，把线程停止，频繁等待与唤醒，导致 JVM 和 OS 交互的次数过多。
notifyAll() 唤醒全部的线程，也浪费线程资源，为了一个线程，不得以唤醒的了全部的线程。
## 4.6 Lock 接口的深入
Lock 接口替换了同步 synchronized ，提供了更加灵活,性能更好的锁定操作。
- 返回线程的阻塞队列：
```Condition newCondition();```
- 生产者与消费者改进为 Lock 接口（借助 Condition 接口 (线程的阻塞队列)）：
   - ① 进入队列的线程，释放锁。
   - ② 出去队列的线程，再次的获取锁。
   - ③ 接口的方法 :  await() 线程释放锁,进入队列。
   - ④ 接口的方法 :  signal() 线程出去队列,再次获取锁。
注意：线程的阻塞队列,依赖 Lock 接口创建。

## 5.1 概述
- 单例设计模式：保证一个类的对象在内存中是唯一的。
- 实现步骤：
   - ① 私有化构造方法。
   - ② 类的内部实例化该类的对象，并且修饰符是 private static 的。
   - ③ 提供一个公开的静态方法，返回刚才实例化的类的对象。
## 5.2 单例模式
- 示例：饿汉式
```java
public class Singleton {

    private static Singleton singleton = new Singleton();

    private Singleton() {}

    public static Singleton getInstance() {
        return singleton;
    }
}
```
- 示例：懒汉式
```java
public class Test {
    public static void main(String[] args) {
        Singleton s1 = Singleton.getInstance();
        Singleton s2 = Singleton.getInstance();

        System.out.println(s1 == s2);
    }
}
```
# 第六章：线程池
## 6.1 概述
- 背景：经常创建和销毁、使用量特别大的资源，比如：并发情况下的线程，对性能影响很大。
- 思路：提前创建好多个线程，放入线程池中，使用的时候直接获取，使用完毕放回池中。可以避免频繁的创建销毁、实现重复利用。
- 好处：
   - ① 提高响应速度（减少了创建新线程的时间）。
   - ② 减低资源消耗（重复利用线程池中的线程，不需要每次使用都创建）。
   - ③ 便于线程管理：
- corePoolSize ：核心池的大小。
- maximumPoolSize ：最大线程数。
- keepAliveTime ：线程没有任务时最多保持多长时间后会终止。
……
## 6.2 线程池相关的API
JDK 5 提供了线程池相关的API：ExecutorService 和 Executors 。
- Executors ：工具类，线程池的工厂类，用于创建并返回不同类型的线程池
- ExecutorService：真正的线程池接口。常见子类ThreadPoolExecutor

## 6.2 实现 Callable 接口
- 和使用 Runnable 相比，Callable功能更加强大：
- 可以有返回值。
- 可以抛出异常。
- 支持泛型的返回值。
## 6.3 ThreadPoolExecutor
构造方法：
```
public ThreadPoolExecutor(int corePoolSize,
int maximumPoolSize,
long keepAliveTime,
TimeUnit unit,
BlockingQueue<Runnable> workQueue,
ThreadFactory threadFactory,
RejectedExecutionHandler handler) {
...
}
```

- 解释：
   - corePoolSize ：核心线程数量。
   - maximumPoolSize ：线程池中的最大线程数量（核心线程数量 + 临时线程数量）。
   - keepAliveTime ：空闲时间值（也可以称为存活时间），即临时线程空闲多少时间被销毁，比如：1。
   - unit ：空闲时间单位（存活时间单位），即临时线程空闲多少时间被销毁，如：TimeUnit.SECONDS 表示秒。
   - workQueue ：任务队列（阻塞队列），如：20 个任务只有 10 个线程同时工作，那么多余的 10 个任务将放到任务队列中，等有线程空闲了，再从任务队列中取出任务继续执行。
   - threadFactory ：创建线程工厂，一般都是采用 Executors.defaultThreadFactory() 方式。
   - handler ：任务的拒绝策略，当任务太多（提交任务超过了线程池中的最大线程数量+任务队列的容量）的时候的解决方案。
   - new ThreadPoolExecutor.AbortPolicy() ：默认的策略，丢弃任务并抛出 RejectedExecutionException 异常。
   - new ThreadPoolExecutor.DiscardPolicy() ：丢失任务，但是不抛出异常，不推荐。
   - new ThreadPoolExecutor.DiscardOldestPolicy() ：抛弃队列中等待最久的任务，然后将当前任务加入到队列中。
   - new ThreadPoolExecutor.CallerRunsPolicy() ：调用任务的run()方法绕过线程池直接执行。
